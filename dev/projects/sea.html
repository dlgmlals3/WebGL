<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seascape Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loading">ğŸŒŠ ë°”ë‹¤ ë¡œë”© ì¤‘...</div>
    
    <div id="info" style="display: none;">
        <h3>ğŸŒŠ Seascape by Alexander Alekseev</h3>
        <p>ë§ˆìš°ìŠ¤ë¡œ ì‹œê°„ ì¡°ì‘ ê°€ëŠ¥</p>
        <p>ì›ë³¸ Shadertoy ì½”ë“œë¥¼ Three.jsë¡œ ë³€í™˜</p>
    </div>

    <!-- Three.js ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ğŸŒŠ Seascape Three.js ë³€í™˜
        let scene, camera, renderer, seascape, clock;
        let mouseX = 0, mouseY = 0;

        function init() {
            console.log("Seascape ì´ˆê¸°í™” ì¤‘...");

            // ê¸°ë³¸ Three.js ì„¤ì •
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // ì‹œê³„
            clock = new THREE.Clock();

            // ì¹´ë©”ë¼ ìœ„ì¹˜ (ì›ë³¸ì²˜ëŸ¼ ê³ ì •)
            camera.position.set(0, 0, 0);

            // ì „ì²´ í™”ë©´ ì¿¼ë“œ ìƒì„±
            createSeascape();

            // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
            setupMouseControls();

            // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
            window.addEventListener('resize', onWindowResize);

            // ë¡œë”© ì™„ë£Œ
            document.getElementById('loading').style.display = 'none';
            document.getElementById('info').style.display = 'block';

            console.log("Seascape ì´ˆê¸°í™” ì™„ë£Œ!");
        }

        function createSeascape() {
            // ì „ì²´ í™”ë©´ì„ ë®ëŠ” í‰ë©´ (ë ˆì´ë§ˆì¹­ìš©)
            const geometry = new THREE.PlaneGeometry(2, 2);

            // ì›ë³¸ Seascape ì…°ì´ë” ë¨¸í‹°ë¦¬ì–¼
            const seascapeMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    iTime: { value: 0 },
                    iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    iMouse: { value: new THREE.Vector2(0, 0) }
                },

                vertexShader: `
                    varying vec2 vUv;
                    
                    void main() {
                        vUv = uv;
                        gl_Position = vec4(position, 1.0);
                    }
                `,

                fragmentShader: `
                    uniform float iTime;
                    uniform vec2 iResolution;
                    uniform vec2 iMouse;
                    
                    varying vec2 vUv;
                    
                    // ì›ë³¸ Seascape ìƒìˆ˜ë“¤
                    const int NUM_STEPS = 8;
                    const float PI = 3.141592;
                    const float EPSILON = 1e-3;
                    
                    // ë°”ë‹¤ ì„¤ì •
                    const int ITER_GEOMETRY = 3;
                    const int ITER_FRAGMENT = 5;
                    const float SEA_HEIGHT = 0.6;
                    const float SEA_CHOPPY = 4.0;
                    const float SEA_SPEED = 0.8;
                    const float SEA_FREQ = 0.16;
                    const vec3 SEA_BASE = vec3(0.0, 0.09, 0.18);
                    const vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6) * 0.6;
                    const mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);
                    
                    // ìˆ˜í•™ í•¨ìˆ˜ë“¤
                    mat3 fromEuler(vec3 ang) {
                        vec2 a1 = vec2(sin(ang.x), cos(ang.x));
                        vec2 a2 = vec2(sin(ang.y), cos(ang.y));
                        vec2 a3 = vec2(sin(ang.z), cos(ang.z));
                        mat3 m;
                        m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x, a1.y*a2.x*a3.x+a3.y*a1.x, -a2.y*a3.x);
                        m[1] = vec3(-a2.y*a1.x, a1.y*a2.y, a2.x);
                        m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x, a1.x*a3.x-a1.y*a3.y*a2.x, a2.y*a3.y);
                        return m;
                    }
                    
                    float hash(vec2 p) {
                        float h = dot(p, vec2(127.1, 311.7));
                        return fract(sin(h) * 43758.5453123);
                    }
                    
                    float noise(in vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return -1.0 + 2.0 * mix(
                            mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), u.x),
                            mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), u.x), 
                            u.y
                        );
                    }
                    
                    // ì¡°ëª… í•¨ìˆ˜ë“¤
                    float diffuse(vec3 n, vec3 l, float p) {
                        return pow(dot(n, l) * 0.4 + 0.6, p);
                    }
                    
                    float specular(vec3 n, vec3 l, vec3 e, float s) {
                        float nrm = (s + 8.0) / (PI * 8.0);
                        return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;
                    }
                    
                    // í•˜ëŠ˜ ìƒ‰ìƒ
                    vec3 getSkyColor(vec3 e) {
                        e.y = (max(e.y, 0.0) * 0.8 + 0.2) * 0.8;
                        return vec3(pow(1.0 - e.y, 2.0), 1.0 - e.y, 0.6 + (1.0 - e.y) * 0.4) * 1.1;
                    }
                    
                    // ë°”ë‹¤ ì˜¥íƒ€ë¸Œ
                    float sea_octave(vec2 uv, float choppy) {
                        uv += noise(uv);
                        vec2 wv = 1.0 - abs(sin(uv));
                        vec2 swv = abs(cos(uv));
                        wv = mix(wv, swv, wv);
                        return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
                    }
                    
                    // ë°”ë‹¤ ë†’ì´ ë§µí•‘
                    float map(vec3 p) {
                        float freq = SEA_FREQ;
                        float amp = SEA_HEIGHT;
                        float choppy = SEA_CHOPPY;
                        vec2 uv = p.xz; 
                        uv.x *= 0.75;
                        
                        float d, h = 0.0;
                        float SEA_TIME = 1.0 + iTime * SEA_SPEED;
                        
                        for(int i = 0; i < ITER_GEOMETRY; i++) {
                            d = sea_octave((uv + SEA_TIME) * freq, choppy);
                            d += sea_octave((uv - SEA_TIME) * freq, choppy);
                            h += d * amp;
                            uv *= octave_m; 
                            freq *= 1.9; 
                            amp *= 0.22;
                            choppy = mix(choppy, 1.0, 0.2);
                        }
                        return p.y - h;
                    }
                    
                    // ìƒì„¸í•œ ë°”ë‹¤ ë†’ì´ ë§µí•‘
                    float map_detailed(vec3 p) {
                        float freq = SEA_FREQ;
                        float amp = SEA_HEIGHT;
                        float choppy = SEA_CHOPPY;
                        vec2 uv = p.xz; 
                        uv.x *= 0.75;
                        
                        float d, h = 0.0;
                        float SEA_TIME = 1.0 + iTime * SEA_SPEED;
                        
                        for(int i = 0; i < ITER_FRAGMENT; i++) {
                            d = sea_octave((uv + SEA_TIME) * freq, choppy);
                            d += sea_octave((uv - SEA_TIME) * freq, choppy);
                            h += d * amp;
                            uv *= octave_m; 
                            freq *= 1.9; 
                            amp *= 0.22;
                            choppy = mix(choppy, 1.0, 0.2);
                        }
                        return p.y - h;
                    }
                    
                    // ë°”ë‹¤ ìƒ‰ìƒ ê³„ì‚°
                    vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {
                        float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);
                        fresnel = min(pow(fresnel, 3.0), 0.5);
                        
                        vec3 reflected = getSkyColor(reflect(eye, n));
                        vec3 refracted = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12;
                        
                        vec3 color = mix(refracted, reflected, fresnel);
                        
                        float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);
                        color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;
                        
                        color += vec3(specular(n, l, eye, 60.0));
                        
                        return color;
                    }
                    
                    // ë²•ì„  ê³„ì‚°
                    vec3 getNormal(vec3 p, float eps) {
                        vec3 n;
                        n.y = map_detailed(p);
                        n.x = map_detailed(vec3(p.x + eps, p.y, p.z)) - n.y;
                        n.z = map_detailed(vec3(p.x, p.y, p.z + eps)) - n.y;
                        n.y = eps;
                        return normalize(n);
                    }
                    
                    // ë†’ì´ë§µ ë ˆì´ íŠ¸ë ˆì´ì‹±
                    float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {
                        float tm = 0.0;
                        float tx = 1000.0;
                        float hx = map(ori + dir * tx);
                        if(hx > 0.0) {
                            p = ori + dir * tx;
                            return tx;
                        }
                        float hm = map(ori + dir * tm);
                        float tmid = 0.0;
                        for(int i = 0; i < NUM_STEPS; i++) {
                            tmid = mix(tm, tx, hm / (hm - hx));
                            p = ori + dir * tmid;
                            float hmid = map(p);
                            if(hmid < 0.0) {
                                tx = tmid;
                                hx = hmid;
                            } else {
                                tm = tmid;
                                hm = hmid;
                            }
                        }
                        return tmid;
                    }
                    
                    // í”½ì…€ ìƒ‰ìƒ ê³„ì‚°
                    vec3 getPixel(in vec2 coord, float time) {
                        vec2 uv = coord / iResolution.xy;
                        uv = uv * 2.0 - 1.0;
                        uv.x *= iResolution.x / iResolution.y;
                        
                        // ë ˆì´ ìƒì„±
                        vec3 ang = vec3(sin(time * 3.0) * 0.1, sin(time) * 0.2 + 0.3, time);
                        vec3 ori = vec3(0.0, 3.5, time * 5.0);
                        vec3 dir = normalize(vec3(uv.xy, -2.0)); 
                        dir.z += length(uv) * 0.14;
                        dir = normalize(dir) * fromEuler(ang);
                        
                        // ë ˆì´ íŠ¸ë ˆì´ì‹±
                        vec3 p;
                        heightMapTracing(ori, dir, p);
                        vec3 dist = p - ori;
                        float EPSILON_NRM = 0.1 / iResolution.x;
                        vec3 n = getNormal(p, dot(dist, dist) * EPSILON_NRM);
                        vec3 light = normalize(vec3(0.0, 1.0, 0.8));
                        
                        // ìƒ‰ìƒ ê³„ì‚°
                        return mix(
                            getSkyColor(dir),
                            getSeaColor(p, n, light, dir, dist),
                            pow(smoothstep(0.0, -0.02, dir.y), 0.2)
                        );
                    }
                    
                    // ë©”ì¸ í•¨ìˆ˜
                    void main() {
                        vec2 fragCoord = gl_FragCoord.xy;
                        float time = iTime * 0.3 + iMouse.x * 0.01;
                        
                        vec3 color = getPixel(fragCoord, time);
                        
                        // í¬ìŠ¤íŠ¸ í”„ë¡œì„¸ì‹±
                        gl_FragColor = vec4(pow(color, vec3(0.65)), 1.0);
                    }
                `,

                side: THREE.DoubleSide
            });

            // ë©”ì‹œ ìƒì„±
            seascape = new THREE.Mesh(geometry, seascapeMaterial);
            scene.add(seascape);

            console.log("Seascape ìƒì„± ì™„ë£Œ!");
        }

        function setupMouseControls() {
            // ë§ˆìš°ìŠ¤ ì›€ì§ì„ ê°ì§€
            document.addEventListener('mousemove', (event) => {
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // ì…°ì´ë” í•´ìƒë„ ì—…ë°ì´íŠ¸
            seascape.material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // ì‹œê°„ ì—…ë°ì´íŠ¸
            const elapsedTime = clock.getElapsedTime();
            seascape.material.uniforms.iTime.value = elapsedTime;

            // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            seascape.material.uniforms.iMouse.value.set(mouseX, mouseY);

            // ë Œë”ë§
            renderer.render(scene, camera);
        }

        // ğŸš€ ì‹œì‘!
        init();
        animate();

        console.log("ğŸŒŠ Seascape ì‹œì‘!");
    </script>
</body>
</html>