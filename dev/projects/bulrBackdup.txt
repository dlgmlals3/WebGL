<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ ì´ë¯¸ì§€ ì²˜ë¦¬</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #222;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            color: white;
            border-radius: 8px;
            min-width: 200px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .value-display {
            font-size: 12px;
            color: #ccc;
        }
        
        #fileInput {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ ì´ë¯¸ì§€ ì²˜ë¦¬</h3>
        <p>ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ê³  ìŠ¬ë¼ì´ë”ë¡œ ë¸”ëŸ¬ ì˜ì—­ì„ ì¡°ì ˆí•˜ì„¸ìš”</p>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>ì´ë¯¸ì§€ ì—…ë¡œë“œ:</label>
            <input type="file" id="fileInput" accept="image/*,.png,.jpg,.jpeg,.gif,.bmp,.webp">
            <div id="uploadStatus" style="font-size: 12px; color: #ccc; margin-top: 5px;">íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”</div>
        </div>
        
        <div class="control-group">
            <label>X Offset </label>
            <input type="range" id="xOffset" min="-1.0" max="1.0" step="0.01" value="0.0">
            <span class="value-display" id="xOffsetValue">0.0</span>
        </div>

        <div class="control-group">
            <label>Y Offset (ë¸”ëŸ¬ ì˜ì—­)</label>
            <input type="range" id="yOffset" min="0" max="1.0" step="0.01" value="1.0">
            <span class="value-display" id="yOffsetValue">1.0</span>
        </div>
        
        <div class="control-group">
            <label>blurStrength </label>
            <input type="range" id="blurStrength" min="1" max="3" step="0.01" value="1">
            <span class="value-display" id="blurStrengthValue">1</span>
        </div>
        
        <div class="control-group">
            <label> Radius </label>
            <input type="range" id="blurRadius" min="1" max="30" step="1" value="17">
            <span class="value-display" id="blurRadiusValue">17</span>
        </div>

        <div class="control-group">
            <label>ë² ì§€ì–´ P1 (ì‹œì‘ì  ê¸°ìš¸ê¸°)</label>
            <input type="range" id="bezierP1" min="0.0" max="1.0" step="0.01" value="0.5">
            <span class="value-display" id="bezierP1Value">0.5</span>
        </div>
        
        <div class="control-group">
            <label>ë² ì§€ì–´ P2 (ëì  ê¸°ìš¸ê¸°)</label>
            <input type="range" id="bezierP2" min="0.0" max="1.0" step="0.01" value="0.5">
            <span class="value-display" id="bezierP2Value">0.5</span>
        </div>
    </div>

    <!-- Three.js ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        let scene, camera, renderer, plane;
        let imageTexture = null;
        let defaultImageData = null;

        function init() {
            console.log("ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ ì•± ì´ˆê¸°í™” ì¤‘...");

            // ê¸°ë³¸ Three.js ì„¤ì •
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // ê¸°ë³¸ ì´ë¯¸ì§€ ìƒì„± (ê³ ì • íŒŒì¼ëª…ìœ¼ë¡œ ë¡œë“œ ì‹œë„)
            createDefaultTexture();
            
            // ì „ì²´ í™”ë©´ í‰ë©´ ìƒì„±
            createImagePlane();

            // ì»¨íŠ¸ë¡¤ ì„¤ì •
            setupControls();

            // íŒŒì¼ ì…ë ¥ ì„¤ì •
            setupFileInput();

            // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
            window.addEventListener('resize', onWindowResize);

            console.log("ì´ˆê¸°í™” ì™„ë£Œ!");
        }

        function createDefaultTexture() {
            // ìƒëŒ€ ê²½ë¡œë¡œ ì´ë¯¸ì§€ íŒŒì¼ ë¡œë“œ (HTML íŒŒì¼ê³¼ ê°™ì€ í´ë”)
            loadImageFromFile('./0.jpg');
        }

        function loadImageFromFile(filename) {
            console.log('ì´ë¯¸ì§€ ë¡œë”© ì‹œë„:', filename);
            
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                console.log('ì´ë¯¸ì§€ ë¡œë“œ ì„±ê³µ:', img.width, 'x', img.height);
                
                try {
                    // ìƒˆ í…ìŠ¤ì²˜ ìƒì„±
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.flipY = false;
                    texture.format = THREE.RGBAFormat;
                    
                    // ê¸°ì¡´ í…ìŠ¤ì²˜ ì •ë¦¬
                    if (imageTexture && imageTexture.dispose) {
                        imageTexture.dispose();
                    }
                    
                    // í…ìŠ¤ì²˜ êµì²´
                    imageTexture = texture;
                    if (plane && plane.material) {
                        plane.material.uniforms.uTexture.value = texture;
                        plane.material.needsUpdate = true;
                    }
                    
                    console.log('í…ìŠ¤ì²˜ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
                    
                } catch (error) {
                    console.error('í…ìŠ¤ì²˜ ìƒì„± ì˜¤ë¥˜:', error);
                    createFallbackTexture();
                }
            };
            
            img.onerror = (error) => {
                console.error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', error);
                console.log('ê¸°ë³¸ ì²´í¬ë³´ë“œ íŒ¨í„´ìœ¼ë¡œ ëŒ€ì²´');
                createFallbackTexture();
            };
            
            // ì´ë¯¸ì§€ ì†ŒìŠ¤ ì„¤ì •
            img.src = filename;
        }

        function createFallbackTexture() {
            // 512x512 ì²´í¬ë³´ë“œ íŒ¨í„´ ìƒì„± (fallback)
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const checkSize = 32;
            for (let x = 0; x < size; x += checkSize) {
                for (let y = 0; y < size; y += checkSize) {
                    const isEven = (Math.floor(x / checkSize) + Math.floor(y / checkSize)) % 2 === 0;
                    ctx.fillStyle = isEven ? '#4a90e2' : '#7bb3f0';
                    ctx.fillRect(x, y, checkSize, checkSize);
                }
            }

            // ì¤‘ì•™ì— í…ìŠ¤íŠ¸ ì¶”ê°€
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('./img0_1920x1200.jpg', size/2, size/2 - 10);
            ctx.font = '16px Arial';
            ctx.fillText('íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', size/2, size/2 + 20);

            imageTexture = new THREE.CanvasTexture(canvas);
            imageTexture.needsUpdate = true;
        }

        function createImagePlane() {
            const geometry = new THREE.PlaneGeometry(2, 2);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTexture: { value: imageTexture },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uXOffset: { value: 0.0 },
                    uYOffset: { value: 0.5 },
                    uBlurStrength: { value: 1 },
                    uBlurRadius: { value: 17 },
                    uBezierP1 : {value : 0},
                    uBezierP2 : {value : 1.0}
                },

                vertexShader: `
                    precision mediump float;
                    varying vec2 vUv;
                    
                    void main() {
                        vUv = uv;
                        gl_Position = vec4(position, 1.0);
                    }
                `,

                fragmentShader: `
                    uniform sampler2D uTexture;
                    uniform vec2 uResolution;
                    uniform float uYOffset;
                    uniform float uXOffset;
                    uniform float uBlurStrength;
                    uniform float uBlurRadius;
                    uniform float uBezierP1;
                    uniform float uBezierP2;
                    varying vec2 vUv;
                    
                    float gaussian(float x, float sigma) {
                        return 1.0 / (sqrt(2.0 * 3.141592) * sigma) * exp(-(x * x) / (2.0 * sigma * sigma));
                    }
                    

                    // ë² ì§€ì–´ ê³¡ì„  (cubic-bezier) ê³„ì‚°
                    float cubicBezier(float t, float p1, float p2) {
                        float invT = 1.0 - t;
                        return 3.0 * invT * invT * t * p1 + 3.0 * invT * t * t * p2 + t * t * t;
                    }
                    
                    // ê·¸ë¼ë°ì´ì…˜ ê°’ ê³„ì‚° (0.0 = ì›ë³¸, 1.0 = ë¸”ëŸ¬)
                    float getGradientValue(vec2 uv, float yOffset) {
                        float t = smoothstep(yOffset, 0.0, uv.y);
                        return clamp(0.0, 1.0, t);
                    }

                    // ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ í•¨ìˆ˜
                    vec4 gaussianBlur(sampler2D tex, vec2 uv, vec2 direction, float radius, float strength) {
                        vec4 color = vec4(0.0);
                        float total = 0.0;
                        
                        // ê°€ìš°ì‹œì•ˆ ê°€ì¤‘ì¹˜ ê³„ì‚°ì„ ìœ„í•œ sigma
                        float sigma = radius / 3.0;
                        int kernelSize = int(radius * 2.0 + 1.0);

                        for (int i = -kernelSize; i <= kernelSize; i++) {                            
                            vec2 offset = direction * float(i) * strength;                            
                            // ê°€ìš°ì‹œì•ˆ ê°€ì¤‘ì¹˜ ê³„ì‚°
                            float weight = gaussian(float(i)), sigma);                                
                            color += texture2D(tex, uv + offset) * weight;
                            total += weight;
                        }
                        
                        return color / total;
                    }

                    /*
                    vec4 gaussianBlurAdaptive(sampler2D tex, vec2 uv, vec2 texelSize, float maxRadius, float radiusMultiplier) {
                        // radiusMultiplierê°€ 0ì´ë©´ radius = 0 (ì›ë³¸), 1ì´ë©´ maxRadius
                        
                        float currentRadius = maxRadius * radiusMultiplier;
                        
                        if (currentRadius < 0.5) {                            
                            return texture2D(tex, uv);
                        }
                        
                        vec4 color = vec4(0.0);
                        float total = 0.0;
                        
                        float sigma = currentRadius / 3.0;
                        int kernelSize = int(currentRadius * 2.0 + 1.0);

                        for (int x = -kernelSize; x <= kernelSize; x++) {
                            for (int y = -kernelSize; y <= kernelSize; y++) {
                                vec2 offset = vec2(x, y) * texelSize;
                                float weight = gaussian(vec2(x, y), sigma);                                
                                color += texture2D(tex, uv + offset) * weight;
                                total += weight;
                            }
                        }
                        return color / total;
                        
                    }
                    */

                    void main() {
                        vec2 uv = vUv;
                        
                        // í…ìŠ¤ì²˜ì—ì„œ ì§ì ‘ í¬ê¸°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ê³ ì •ê°’ ì‚¬ìš©
                        vec2 texelSize = vec2(1.0 / uResolution); // ê¸°ë³¸ê°’, ì‹¤ì œë¡œëŠ” ë™ì ìœ¼ë¡œ ê³„ì‚°ë˜ì–´ì•¼ í•¨
                        
                        // Y ì˜¤í”„ì…‹ì— ë”°ë¼ ë¸”ëŸ¬ ì˜ì—­ ê²°ì •
                        // uXOffsetì´ 0ì´ë©´ ì •í™•íˆ ë°˜ë°˜, -1ì´ë©´ ì „ì²´ ë¸”ëŸ¬, 1ì´ë©´ ë¸”ëŸ¬ ì—†ìŒ
                        float blurBoundary = 0.5 + uXOffset * 0.5;
                        vec4 originalColor = texture2D(uTexture, uv);
                        
                        if (uv.x < blurBoundary) {
                            //float blurIntensity = getGradientValue(uv, uYOffset);                            
                            //float bezierValue = cubicBezier(blurIntensity, uBezierP1, uBezierP2);                            
                            //gl_FragColor = gaussianBlurAdaptive(uTexture, uv, texelSize, uBlurRadius, bezierValue);
                        } else {
                            
                            // ì™¼ìª½ ì˜ì—­: ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ ì ìš©
                            vec4 blurredColor = gaussianBlur(uTexture, uv, 
                                vec2(texelSize, 0.0) , uBlurRadius, uBlurStrength);
                            gl_FragColor = blurredColor;
                            
                            
                            float gradientValue = getGradientValue(uv, uYOffset);                                                    
                            float bezierValue = cubicBezier(gradientValue, uBezierP1, uBezierP2);
                            //gl_FragColor = vec4(bezierValue, 0.0, 0.0, 1.0);
                            gl_FragColor = mix(originalColor, blurredColor, bezierValue);
                        }
                        
                        // ê²½ê³„ì„  í‘œì‹œ (ì„ íƒì )
                        float borderWidth = 0.002;
                        if (abs(uv.x - blurBoundary) < borderWidth) {
                            gl_FragColor = mix(gl_FragColor, vec4(1.0, 1.0, 0.0, 1.0), 0.3);
                        }
                    }
                `,

                side: THREE.DoubleSide
            });

            plane = new THREE.Mesh(geometry, material);
            scene.add(plane);
        }

        function setupControls() {
            // X Offset ìŠ¬ë¼ì´ë”
            const xOffsetSlider = document.getElementById('xOffset');
            const xOffsetValue = document.getElementById('xOffsetValue');
            xOffsetSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                plane.material.uniforms.uXOffset.value = value;
                yOffsetValue.textContent = value.toFixed(2);
            });

            // Y Offset ìŠ¬ë¼ì´ë”
            const yOffsetSlider = document.getElementById('yOffset');
            const yOffsetValue = document.getElementById('yOffsetValue');
            yOffsetSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                plane.material.uniforms.uYOffset.value = value;
                yOffsetValue.textContent = value.toFixed(2);
            });

            // ë¸”ëŸ¬ ê°•ë„ ìŠ¬ë¼ì´ë”
            const blurStrengthSlider = document.getElementById('blurStrength');
            const blurStrengthValue = document.getElementById('blurStrengthValue');
            blurStrengthSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                plane.material.uniforms.uBlurStrength.value = value;
                blurStrengthValue.textContent = value.toFixed(1);
                console.log('ë¸”ëŸ¬ ê°•ë„ ë³€ê²½:', value);
            });

            // ë¸”ëŸ¬ ë°˜ì§€ë¦„ ìŠ¬ë¼ì´ë”
            const blurRadiusSlider = document.getElementById('blurRadius');
            const blurRadiusValue = document.getElementById('blurRadiusValue');
            blurRadiusSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                plane.material.uniforms.uBlurRadius.value = value;
                blurRadiusValue.textContent = value;
                console.log('ë¸”ëŸ¬ ë°˜ì§€ë¦„ ë³€ê²½:', value);
            });
            
            const bezierP1Slider = document.getElementById('bezierP1');
            const bezierP1Value = document.getElementById('bezierP1Value');
            bezierP1Slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                plane.material.uniforms.uBezierP1.value = value;
                bezierP1Value.textContent = value
                console.log('ë² ì§€ì–´ P1 ë³€ê²½:', value);
            });
            
            const bezierP2Slider = document.getElementById('bezierP2');
            const bezierP2Value = document.getElementById('bezierP2Value');
            bezierP2Slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                plane.material.uniforms.uBezierP2.value = value;
                bezierP2Value.textContent = value
                console.log('ë² ì§€ì–´ P2 ë³€ê²½:', value);
            });
        }

        function setupFileInput() {
            const fileInput = document.getElementById('fileInput');
            const uploadStatus = document.getElementById('uploadStatus');
            
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                console.log('íŒŒì¼ ì„ íƒë¨:', file);
                
                if (!file) {
                    uploadStatus.textContent = 'íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”';
                    uploadStatus.style.color = '#ccc';
                    return;
                }
                
                uploadStatus.textContent = 'íŒŒì¼ ì²˜ë¦¬ ì¤‘...';
                uploadStatus.style.color = 'yellow';
                
                // íŒŒì¼ íƒ€ì… ì²´í¬
                const validTypes = ['image/png', 'image/jpg', 'image/jpeg', 'image/gif', 'image/bmp', 'image/webp'];
                console.log('íŒŒì¼ íƒ€ì…:', file.type);
                
                if (!file.type.startsWith('image/') && !validTypes.includes(file.type)) {
                    uploadStatus.textContent = 'ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤';
                    uploadStatus.style.color = 'red';
                    return;
                }
                
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    console.log('íŒŒì¼ ì½ê¸° ì™„ë£Œ, ë°ì´í„° ê¸¸ì´:', e.target.result.length);
                    uploadStatus.textContent = 'ì´ë¯¸ì§€ ë¡œë”© ì¤‘...';
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        console.log('ì´ë¯¸ì§€ ë¡œë“œ ì„±ê³µ:', img.width, 'x', img.height);
                        uploadStatus.textContent = `ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ (${img.width}x${img.height})`;
                        uploadStatus.style.color = 'lightgreen';
                        
                        try {
                            // ìƒˆ í…ìŠ¤ì²˜ ìƒì„±
                            const texture = new THREE.Texture(img);
                            texture.needsUpdate = true;
                            texture.minFilter = THREE.LinearFilter;
                            texture.magFilter = THREE.LinearFilter;
                            texture.wrapS = THREE.ClampToEdgeWrapping;
                            texture.wrapT = THREE.ClampToEdgeWrapping;
                            texture.flipY = false;
                            texture.format = THREE.RGBAFormat;
                            
                            // ê¸°ì¡´ í…ìŠ¤ì²˜ ì •ë¦¬
                            if (imageTexture && imageTexture.dispose) {
                                imageTexture.dispose();
                            }
                            
                            // í…ìŠ¤ì²˜ êµì²´
                            imageTexture = texture;
                            plane.material.uniforms.uTexture.value = texture;
                            plane.material.needsUpdate = true;
                            
                            console.log('ì—…ë¡œë“œëœ í…ìŠ¤ì²˜ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
                            
                        } catch (error) {
                            console.error('í…ìŠ¤ì²˜ ìƒì„± ì˜¤ë¥˜:', error);
                            uploadStatus.textContent = 'í…ìŠ¤ì²˜ ìƒì„± ì‹¤íŒ¨';
                            uploadStatus.style.color = 'red';
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', error);
                        uploadStatus.textContent = 'ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨';
                        uploadStatus.style.color = 'red';
                    };
                    
                    // ì´ë¯¸ì§€ ì†ŒìŠ¤ ì„¤ì •
                    img.src = e.target.result;
                };
                
                reader.onerror = (error) => {
                    console.error('íŒŒì¼ ì½ê¸° ì‹¤íŒ¨:', error);
                    uploadStatus.textContent = 'íŒŒì¼ ì½ê¸° ì‹¤íŒ¨';
                    uploadStatus.style.color = 'red';
                };
                
                // íŒŒì¼ì„ Data URLë¡œ ì½ê¸°
                reader.readAsDataURL(file);
            });
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            plane.material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // ğŸš€ ì‹œì‘!
        init();
        animate();

        console.log("ğŸ¨ ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ ì•± ì‹œì‘!");
    </script>
</body>
</html>